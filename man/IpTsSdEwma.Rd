% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ip_tssd_ewma.R
\name{IpTsSdEwma}
\alias{IpTsSdEwma}
\title{Incremental Processing Two-Stage Shift-Detection based on EWMA}
\usage{
IpTsSdEwma(data, n.train, threshold, l = 3, m = 5,
  to.next.iteration = list(last.res = NULL, to.check = NULL, last.m = NULL))
}
\arguments{
\item{threshold}{Error smoothing constant.}

\item{l}{Control limit multiplier.}

\item{m}{Length of the subsequences for applying the Kolmogorov-Smirnov test.}

\item{to.next.iteration}{list with the necessary parameters to execute in
the next iteration}

\item{train.data}{Numerical vector that conforms the training set.}

\item{test.data}{Numerical vector that conforms the test set.}
}
\value{
A list of the following items.

  \item{last.data.checked}{Anomaly results of the last m results of the
  previous iteration. Data set conformed by the following columns.}
  \itemize{
     \item \code{is.anomaly} 1 if the value is anomalous 0 otherwise.
     \item \code{ucl} Upper control limit.
     \item \code{lcl} Lower control limit.
 }
 \item{checked.results}{Anomaly results of the data set excluding the
 last m values because they could not be verified. Data set conformed by the
 following columns: is.anomaly, ucl, lcl.}
 \item{to.next.iteration}{Last result returned by the algorithm. Is a list
 containing the following items.}
 \itemize{
     \item \code{last.res} Last result returned by the aplicaction of
     SD-EWMA function with the calculations of the parameters of the last run
     that are necessary for the next run.
     \item \code{to.check} Subsecuence of the last remaining unchecked
     values to be checked in the next iteration. Data set conformed by the
     following columns: is.anomaly, ucl, lcl, value.
     \item \code{last.m} Subsecuence of the m values prior to the to.check
     subsecuence necessary to verify the values in to.check.
 }
}
\description{
\code{IpTsSdEwma} allows you to calculate anomalies using
TSSD-EWMA in an incremental processing mode. See also
\code{\link{OipTsSdEwma}} the optimized and faster function of the same. This
algorithm is a novel method for covariate shift-detection tests based on a
two-stage structure for univariate time-series. TSSD-EWMA works in two
phases. In the first phase, it detects anomalies using the SD-EWMA
\code{\link{CpSdEwma}} algorithm. In the second phase, it checks the veracity
of the anomalies using the Kolmogorov-Simirnov test to reduce false alarms.
}
\details{
\code{train.data} and \code{test.data} must be numerical vectors
without NA values. \code{threshold} must be a numeric value between 0 and 1.
It is recommended to use low values such as 0.01 or 0.05. By default, 0.01 is
used. Finally, \code{l} is the parameter that determines the control limits.
By default, 3 is used. \code{m} is the length of the subsequences for
applying the Kolmogorov-Smirnov test. By default, 5 is used. It should be
noted that the last m values have not been verified because you need other m
values to be able to perform the verification. Finally
\code{to.next.iteration} is the last result returned by some previous
execution of this algorithm. The first time the algorithm is executed its
value is NULL. However, if you want to run a new batch of data without having
to include it in the old data set and restart the process you only need to
add the last results returned by the last run.
}
\examples{
## EXAMPLE 1: ----------------------
## You can use it in the same way as in CpSdEwma passing the whole dataset as
## an argument.

## Generate data
set.seed(100)
n <- 500
x <- sample(1:100, n, replace = TRUE)
x[70:90] <- sample(110:115, 21, replace = TRUE)
x[25] <- 200
x[320] <- 170
df=data.frame(timestamp=1:n,value=x)

## Calculate anomalies
result <- IpTsSdEwma(
  data = df$value,
  n.train = 5,
  threshold = 0.01,
  l = 3,
  m = 20
)
res <- cbind(df[6:n,], rbind(result$last.data.checked, result$checked.results,
             result$to.next.iteration$to.check[, -4]))
rownames(res) <- 1:(n-5)

## Plot results
res <- res[1:500,]
y.limits <- c(-150,250)
plot(x = res$timestamp, y = res$value, type = "l", ylim = y.limits,
     xlab = "timestamp", ylab = "value", main = "TSSD-EWMA ANOMALY DETECTOR")
points(x = res[res$is.anomaly == 1, "timestamp"],
       y = res[res$is.anomaly == 1, "value"], pch=4, col="red", lwd = 2)
par(new=TRUE)
plot(x = res$timestamp, y = res$ucl, type="l", col="red", xaxt="n",
     ylim = y.limits, xlab = "", ylab = "")
par(new=TRUE)
plot(x = res$timestamp, y = res$lcl, type="l", col="red", xaxt="n",
     ylim = y.limits, xlab = "", ylab = "")

## EXAMPLE 2: ----------------------
## You can use it you can use it in an incremental way. This is an example using
## stream library. This library allows you to simulate streaming operation.

# install.packages("stream")
library("stream")

## Generate data
set.seed(100)
n <- 500
x <- sample(1:100, n, replace = TRUE)
x[70:90] <- sample(110:115, 21, replace = TRUE)
x[25] <- 200
x[320] <- 170
df=data.frame(timestamp=1:n,value=x)
dsd_df <- DSD_Memory(df)

## Initialize parameters for the loop
last.res <- NULL
res <- NULL
nread <- 100
numIter <- n\%/\%nread
m <- 20

## Calculate anomalies
for(i in 1:numIter) {
  # read new data
  newRow <- get_points(dsd_df, n = nread, outofpoints = "ignore")
  # calculate if it's an anomaly
  last.res <- IpTsSdEwma(
    data = newRow$value,
    n.train = 5,
    threshold = 0.01,
    l = 3,
    m = m,
    to.next.iteration = last.res$to.next.iteration
  )
  # prepare result
  if(!is.null(last.res$last.data.checked)){
    res <- rbind(res, cbind(last.timestamp, last.res$last.data.checked))
  }
  if(!is.null(last.res$checked.results)){
    init <- nread - (nrow(last.res$checked.results) +
            nrow(last.res$to.next.iteration$to.check)) + 1
    end <- init + nrow(last.res$checked.results) - 1
    res <- rbind(res, cbind(newRow[init:end,], last.res$checked.results))
  }
  if(i == numIter){
    res <- rbind(res,
           cbind(timestamp = newRow[
                             (nread - nrow(last.res$to.next.iteration$to.check)
                             + 1):nread, "timestamp"],
                 last.res$to.next.iteration$to.check))
  }
  last.timestamp <- newRow[(nread-m+1):nread,]
}

## Plot results
rownames(res) <- 1:(n-5)
y.limits <- c(-150,250)
plot(x = res$timestamp, y = res$value, type = "l", ylim = y.limits,
     xlab = "timestamp", ylab = "value", main = "TSSD-EWMA ANOMALY DETECTOR")
points(x = res[res$is.anomaly == 1, "timestamp"],
       y = res[res$is.anomaly == 1, "value"], pch=4, col="red", lwd = 2)
par(new=TRUE)
plot(x = res$timestamp, y = res$ucl, type="l", col="red", xaxt="n",
     ylim = y.limits, xlab = "", ylab = "")
par(new=TRUE)
plot(x = res$timestamp, y = res$lcl, type="l", col="red", xaxt="n",
     ylim = y.limits, xlab = "", ylab = "")
}
\references{
Raza, H., Prasad, G., & Li, Y. (03 de 2015). EWMA model based
shift-detection methods for detecting covariate shifts in non-stationary
environments. Pattern Recognition, 48(3), 659-669.
}
